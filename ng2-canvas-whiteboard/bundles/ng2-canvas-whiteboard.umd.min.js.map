{"version":3,"file":"ng2-canvas-whiteboard.umd.min.js","sources":["../../src/canvas-whiteboard.component.ts","../../src/shapes/canvas-whiteboard-shape-selector.component.ts","../../src/canvas-whiteboard-colorpicker.component.ts","../../src/shapes/canvas-whiteboard-shape-preview.component.ts","../../src/ng2-canvas-whiteboard.module.ts","../../src/canvas-whiteboard-update.model.ts","../../src/template.ts","../../src/canvas-whiteboard.service.ts","../../src/canvas-whiteboard-point.ts","../../src/shapes/canvas-whiteboard-shape-options.ts","../../src/shapes/canvas-whiteboard-shape.ts","../../src/shapes/circle-shape.ts","../../src/shapes/rectangle-shape.ts","../../src/shapes/free-hand-shape.ts","../../src/shapes/smiley-shape.ts","../../src/shapes/star-shape.ts","../../src/shapes/line-shape.ts","../../src/shapes/canvas-whiteboard-shape.service.ts"],"sourcesContent":["import {\n    Component,\n    Input,\n    Output,\n    EventEmitter,\n    ViewChild,\n    ElementRef,\n    OnInit,\n    OnChanges, OnDestroy, AfterViewInit, NgZone, ChangeDetectorRef\n} from '@angular/core';\nimport {CanvasWhiteboardUpdate, CanvasWhiteboardUpdateType} from \"./canvas-whiteboard-update.model\";\nimport {DEFAULT_STYLES} from \"./template\";\nimport {CanvasWhiteboardService} from \"./canvas-whiteboard.service\";\nimport {CanvasWhiteboardOptions} from \"./canvas-whiteboard-options\";\nimport {CanvasWhiteboardShape} from \"./shapes/canvas-whiteboard-shape\";\nimport {CanvasWhiteboardPoint} from \"./canvas-whiteboard-point\";\nimport {CanvasWhiteboardShapeService, INewCanvasWhiteboardShape} from \"./shapes/canvas-whiteboard-shape.service\";\nimport {CanvasWhiteboardShapeOptions} from \"./shapes/canvas-whiteboard-shape-options\";\nimport {fromEvent, Subscription} from \"rxjs\";\nimport {debounceTime, distinctUntilChanged} from \"rxjs/operators\";\nimport {cloneDeep, isEqual} from \"lodash\";\n\n@Component({\n    selector: 'canvas-whiteboard',\n    template:\n            `\n        <div class=\"canvas_wrapper_div\">\n            <div class=\"canvas_whiteboard_buttons\">\n                <canvas-whiteboard-shape-selector *ngIf=\"shapeSelectorEnabled\"\n                                                  [showShapeSelector]=\"showShapeSelector\"\n                                                  [selectedShapeConstructor]=\"selectedShapeConstructor\"\n                                                  [shapeOptions]=\"generateShapePreviewOptions()\"\n                                                  (onToggleShapeSelector)=\"toggleShapeSelector($event)\"\n                                                  (onShapeSelected)=\"selectShape($event)\"></canvas-whiteboard-shape-selector>\n\n                <canvas-whiteboard-colorpicker *ngIf=\"colorPickerEnabled || fillColorPickerEnabled\"\n                                               [previewText]=\"'Fill'\"\n                                               [showColorPicker]=\"showFillColorPicker\"\n                                               [selectedColor]=\"fillColor\"\n                                               (onToggleColorPicker)=\"toggleFillColorPicker($event)\"\n                                               (onColorSelected)=\"changeFillColor($event)\">\n                </canvas-whiteboard-colorpicker>\n\n                <canvas-whiteboard-colorpicker *ngIf=\"colorPickerEnabled || strokeColorPickerEnabled\"\n                                               [previewText]=\"'Stroke'\"\n                                               [showColorPicker]=\"showStrokeColorPicker\"\n                                               [selectedColor]=\"strokeColor\"\n                                               (onToggleColorPicker)=\"toggleStrokeColorPicker($event)\"\n                                               (onColorSelected)=\"changeStrokeColor($event)\">\n                </canvas-whiteboard-colorpicker>\n\n\n                <button *ngIf=\"drawButtonEnabled\" (click)=\"toggleDrawingEnabled()\"\n                        [class.canvas_whiteboard_button-draw_animated]=\"getDrawingEnabled()\"\n                        class=\"canvas_whiteboard_button canvas_whiteboard_button-draw\" type=\"button\">\n                    <i [class]=\"drawButtonClass\" aria-hidden=\"true\"></i> {{drawButtonText}}\n                </button>\n\n                <button *ngIf=\"clearButtonEnabled\" (click)=\"clearCanvasLocal()\" type=\"button\"\n                        class=\"canvas_whiteboard_button canvas_whiteboard_button-clear\">\n                    <i [class]=\"clearButtonClass\" aria-hidden=\"true\"></i> {{clearButtonText}}\n                </button>\n\n                <button *ngIf=\"undoButtonEnabled\" (click)=\"undoLocal()\" type=\"button\"\n                        class=\"canvas_whiteboard_button canvas_whiteboard_button-undo\">\n                    <i [class]=\"undoButtonClass\" aria-hidden=\"true\"></i> {{undoButtonText}}\n                </button>\n\n                <button *ngIf=\"redoButtonEnabled\" (click)=\"redoLocal()\" type=\"button\"\n                        class=\"canvas_whiteboard_button canvas_whiteboard_button-redo\">\n                    <i [class]=\"redoButtonClass\" aria-hidden=\"true\"></i> {{redoButtonText}}\n                </button>\n                <button *ngIf=\"saveDataButtonEnabled\" (click)=\"saveLocal()\" type=\"button\"\n                        class=\"canvas_whiteboard_button canvas_whiteboard_button-save\">\n                    <i [class]=\"saveDataButtonClass\" aria-hidden=\"true\"></i> {{saveDataButtonText}}\n                </button>\n            </div>\n            <canvas #canvas class=\"canvas_whiteboard\"></canvas>\n            <canvas #incompleteShapesCanvas class=\"incomplete_shapes_canvas_whiteboard\"\n                    (mousedown)=\"canvasUserEvents($event)\" (mouseup)=\"canvasUserEvents($event)\"\n                    (mousemove)=\"canvasUserEvents($event)\" (mouseout)=\"canvasUserEvents($event)\"\n                    (touchstart)=\"canvasUserEvents($event)\" (touchmove)=\"canvasUserEvents($event)\"\n                    (touchend)=\"canvasUserEvents($event)\" (touchcancel)=\"canvasUserEvents($event)\"></canvas>\n        </div>\n    `,\n    styles: [DEFAULT_STYLES]\n})\nexport class CanvasWhiteboardComponent implements OnInit, AfterViewInit, OnChanges, OnDestroy {\n    @Input() options: CanvasWhiteboardOptions;\n\n    // Number of ms to wait before sending out the updates as an array\n    @Input() batchUpdateTimeoutDuration: number = 100;\n\n    private _imageUrl: string;\n    @Input() set imageUrl(imageUrl: string) {\n        this._imageUrl = imageUrl;\n        this._imageElement = null;\n        this._redrawHistory();\n    }\n\n    get imageUrl() {\n        return this._imageUrl;\n    }\n\n    @Input() aspectRatio: number;\n    @Input() drawButtonClass: string;\n    @Input() clearButtonClass: string;\n    @Input() undoButtonClass: string;\n    @Input() redoButtonClass: string;\n    @Input() saveDataButtonClass: string;\n    @Input() drawButtonText: string = \"\";\n    @Input() clearButtonText: string = \"\";\n    @Input() undoButtonText: string = \"\";\n    @Input() redoButtonText: string = \"\";\n    @Input() saveDataButtonText: string = \"\";\n    @Input() drawButtonEnabled: boolean = true;\n    @Input() clearButtonEnabled: boolean = true;\n    @Input() undoButtonEnabled: boolean = false;\n    @Input() redoButtonEnabled: boolean = false;\n    @Input() saveDataButtonEnabled: boolean = false;\n    @Input() shouldDownloadDrawing: boolean = true;\n    /** @deprecated. Replaced with strokeColorPickerEnabled and fillColorPickerEnabled inputs */\n    @Input() colorPickerEnabled: boolean = false;\n    @Input() strokeColorPickerEnabled: boolean = false;\n    @Input() fillColorPickerEnabled: boolean = false;\n\n    @Input() lineWidth: number = 2;\n    @Input() strokeColor: string = \"rgba(0, 0, 0, 1)\";\n    @Input() startingColor: string = \"#fff\";\n    @Input() scaleFactor: number = 0;\n    @Input() drawingEnabled: boolean = false;\n    @Input() showStrokeColorPicker: boolean = false;\n    @Input() showFillColorPicker: boolean = false;\n    @Input() downloadedFileName: string;\n\n    @Input() lineJoin: string = \"round\";\n    @Input() lineCap: string = \"round\";\n    @Input() shapeSelectorEnabled: boolean = true;\n    @Input() showShapeSelector: boolean = false;\n    @Input() fillColor: string = \"rgba(0,0,0,0)\";\n\n    @Output() onClear = new EventEmitter<any>();\n    @Output() onUndo = new EventEmitter<any>();\n    @Output() onRedo = new EventEmitter<any>();\n    @Output() onBatchUpdate = new EventEmitter<CanvasWhiteboardUpdate[]>();\n    @Output() onImageLoaded = new EventEmitter<any>();\n    @Output() onSave = new EventEmitter<string | Blob>();\n\n    @ViewChild('canvas', { static: true }) canvas: ElementRef;\n    context: CanvasRenderingContext2D;\n\n    @ViewChild('incompleteShapesCanvas', { static: true }) private _incompleteShapesCanvas: ElementRef;\n    private _incompleteShapesCanvasContext: CanvasRenderingContext2D;\n    private _incompleteShapesMap: Map<string, CanvasWhiteboardShape>;\n\n    private _imageElement: any;\n\n    private _canDraw = true;\n\n    private _clientDragging = false;\n\n    private _updateHistory: CanvasWhiteboardUpdate[] = [];\n    private _lastUUID: string;\n    private _shapesMap: Map<string, CanvasWhiteboardShape>;\n\n    private _undoStack: string[] = []; // Stores the value of start and count for each continuous stroke\n    private _redoStack: string[] = [];\n    private _batchUpdates: CanvasWhiteboardUpdate[] = [];\n    private _updatesNotDrawn: any = [];\n\n    private _updateTimeout: any;\n\n    private _canvasWhiteboardServiceSubscriptions: Subscription[] = [];\n    private _resizeSubscription: Subscription;\n    private _registeredShapesSubscription: Subscription;\n\n    selectedShapeConstructor: INewCanvasWhiteboardShape<CanvasWhiteboardShape>;\n    canvasWhiteboardShapePreviewOptions: CanvasWhiteboardShapeOptions;\n\n    constructor(private ngZone: NgZone,\n                private _changeDetector: ChangeDetectorRef,\n                private _canvasWhiteboardService: CanvasWhiteboardService,\n                private _canvasWhiteboardShapeService: CanvasWhiteboardShapeService) {\n        this._shapesMap = new Map<string, CanvasWhiteboardShape>();\n        this._incompleteShapesMap = new Map<string, CanvasWhiteboardShape>();\n        this.canvasWhiteboardShapePreviewOptions = this.generateShapePreviewOptions();\n    }\n\n    /**\n     * Initialize the canvas drawing context. If we have an aspect ratio set up, the canvas will resize\n     * according to the aspect ratio.\n     */\n    ngOnInit(): void {\n        this._initInputsFromOptions(this.options);\n        this._initCanvasEventListeners();\n        this._initCanvasServiceObservables();\n        this.context = this.canvas.nativeElement.getContext(\"2d\");\n        this._incompleteShapesCanvasContext = this._incompleteShapesCanvas.nativeElement.getContext(\"2d\");\n    }\n\n    /**\n     * If an image exists and it's url changes, we need to redraw the new image on the canvas.\n     */\n    ngOnChanges(changes: any): void {\n        if (changes.options && !isEqual(changes.options.currentValue, changes.options.previousValue)) {\n            this._initInputsFromOptions(changes.options.currentValue);\n        }\n    }\n\n    /**\n     * Recalculate the width and height of the canvas after the view has been fully initialized\n     */\n    ngAfterViewInit(): void {\n        this._calculateCanvasWidthAndHeight();\n        this._redrawHistory();\n    }\n\n    /**\n     * This method reads the options which are helpful since they can be really long when specified in HTML\n     * This method is also called everytime the options object changes\n     * For security reasons we must check each item on its own since if we iterate the keys\n     * we may be injected with malicious values\n     *\n     * @param options\n     */\n    private _initInputsFromOptions(options: CanvasWhiteboardOptions) {\n        if (options) {\n            if (!this._isNullOrUndefined(options.batchUpdateTimeoutDuration)) this.batchUpdateTimeoutDuration = options.batchUpdateTimeoutDuration;\n            if (!this._isNullOrUndefined(options.imageUrl)) this.imageUrl = options.imageUrl;\n            if (!this._isNullOrUndefined(options.aspectRatio)) this.aspectRatio = options.aspectRatio;\n            if (!this._isNullOrUndefined(options.drawButtonClass)) this.drawButtonClass = options.drawButtonClass;\n            if (!this._isNullOrUndefined(options.clearButtonClass)) this.clearButtonClass = options.clearButtonClass;\n            if (!this._isNullOrUndefined(options.undoButtonClass)) this.undoButtonClass = options.undoButtonClass;\n            if (!this._isNullOrUndefined(options.redoButtonClass)) this.redoButtonClass = options.redoButtonClass;\n            if (!this._isNullOrUndefined(options.saveDataButtonClass)) this.saveDataButtonClass = options.saveDataButtonClass;\n            if (!this._isNullOrUndefined(options.drawButtonText)) this.drawButtonText = options.drawButtonText;\n            if (!this._isNullOrUndefined(options.clearButtonText)) this.clearButtonText = options.clearButtonText;\n            if (!this._isNullOrUndefined(options.undoButtonText)) this.undoButtonText = options.undoButtonText;\n            if (!this._isNullOrUndefined(options.redoButtonText)) this.redoButtonText = options.redoButtonText;\n            if (!this._isNullOrUndefined(options.saveDataButtonText)) this.saveDataButtonText = options.saveDataButtonText;\n            if (!this._isNullOrUndefined(options.drawButtonEnabled)) this.drawButtonEnabled = options.drawButtonEnabled;\n            if (!this._isNullOrUndefined(options.clearButtonEnabled)) this.clearButtonEnabled = options.clearButtonEnabled;\n            if (!this._isNullOrUndefined(options.undoButtonEnabled)) this.undoButtonEnabled = options.undoButtonEnabled;\n            if (!this._isNullOrUndefined(options.redoButtonEnabled)) this.redoButtonEnabled = options.redoButtonEnabled;\n            if (!this._isNullOrUndefined(options.saveDataButtonEnabled)) this.saveDataButtonEnabled = options.saveDataButtonEnabled;\n            if (!this._isNullOrUndefined(options.colorPickerEnabled)) this.colorPickerEnabled = options.colorPickerEnabled;\n            if (!this._isNullOrUndefined(options.strokeColorPickerEnabled)) this.strokeColorPickerEnabled = options.strokeColorPickerEnabled;\n            if (!this._isNullOrUndefined(options.fillColorPickerEnabled)) this.fillColorPickerEnabled = options.fillColorPickerEnabled;\n            if (!this._isNullOrUndefined(options.lineWidth)) this.lineWidth = options.lineWidth;\n            if (!this._isNullOrUndefined(options.strokeColor)) this.strokeColor = options.strokeColor;\n            if (!this._isNullOrUndefined(options.shouldDownloadDrawing)) this.shouldDownloadDrawing = options.shouldDownloadDrawing;\n            if (!this._isNullOrUndefined(options.startingColor)) this.startingColor = options.startingColor;\n            if (!this._isNullOrUndefined(options.scaleFactor)) this.scaleFactor = options.scaleFactor;\n            if (!this._isNullOrUndefined(options.drawingEnabled)) this.drawingEnabled = options.drawingEnabled;\n            if (!this._isNullOrUndefined(options.downloadedFileName)) this.downloadedFileName = options.downloadedFileName;\n            if (!this._isNullOrUndefined(options.lineJoin)) this.lineJoin = options.lineJoin;\n            if (!this._isNullOrUndefined(options.lineCap)) this.lineCap = options.lineCap;\n            if (!this._isNullOrUndefined(options.shapeSelectorEnabled)) this.shapeSelectorEnabled = options.shapeSelectorEnabled;\n            if (!this._isNullOrUndefined(options.showShapeSelector)) this.showShapeSelector = options.showShapeSelector;\n            if (!this._isNullOrUndefined(options.fillColor)) this.fillColor = options.fillColor;\n            if (!this._isNullOrUndefined(options.showStrokeColorPicker)) this.showStrokeColorPicker = options.showStrokeColorPicker;\n            if (!this._isNullOrUndefined(options.showFillColorPicker)) this.showFillColorPicker = options.showFillColorPicker;\n        }\n    }\n\n    private _isNullOrUndefined(property: any): boolean {\n        return property === null || property === undefined;\n    }\n\n    /**\n     * Init global window listeners like resize and keydown\n     */\n    private _initCanvasEventListeners(): void {\n        this.ngZone.runOutsideAngular(() => {\n            this._resizeSubscription = fromEvent(window, 'resize')\n                .pipe(\n                    debounceTime(200),\n                    distinctUntilChanged()\n                )\n                .subscribe(() => {\n                    this.ngZone.run(() => {\n                        this._redrawCanvasOnResize();\n                    });\n                });\n        });\n\n        window.addEventListener(\"keydown\", this._canvasKeyDown.bind(this), false);\n    }\n\n    /**\n     * Subscribes to new signals in the canvas whiteboard service and executes methods accordingly\n     * Because of circular publishing and subscribing, the canvas methods do not use the service when\n     * local actions are completed (Ex. clicking undo from the button inside this component)\n     */\n    private _initCanvasServiceObservables(): void {\n        this._canvasWhiteboardServiceSubscriptions.push(this._canvasWhiteboardService.canvasDrawSubject$\n            .subscribe(updates => this.drawUpdates(updates)));\n        this._canvasWhiteboardServiceSubscriptions.push(this._canvasWhiteboardService.canvasClearSubject$\n            .subscribe(() => this.clearCanvas()));\n        this._canvasWhiteboardServiceSubscriptions.push(this._canvasWhiteboardService.canvasUndoSubject$\n            .subscribe((updateUUD) => this._undoCanvas(updateUUD)));\n        this._canvasWhiteboardServiceSubscriptions.push(this._canvasWhiteboardService.canvasRedoSubject$\n            .subscribe((updateUUD) => this._redoCanvas(updateUUD)));\n\n        this._registeredShapesSubscription = this._canvasWhiteboardShapeService.registeredShapes$.subscribe((shapes) => {\n            if (!this.selectedShapeConstructor || !this._canvasWhiteboardShapeService.isRegisteredShape(this.selectedShapeConstructor)) {\n                this.selectedShapeConstructor = shapes[0];\n            }\n        });\n    }\n\n    /**\n     * Calculate the canvas width and height from it's parent container width and height (use aspect ratio if needed)\n     */\n    private _calculateCanvasWidthAndHeight(): void {\n        this.context.canvas.width = this.canvas.nativeElement.parentNode.clientWidth;\n        if (this.aspectRatio) {\n            this.context.canvas.height = this.canvas.nativeElement.parentNode.clientWidth * this.aspectRatio;\n        } else {\n            this.context.canvas.height = this.canvas.nativeElement.parentNode.clientHeight;\n        }\n\n        this._incompleteShapesCanvasContext.canvas.width = this.context.canvas.width;\n        this._incompleteShapesCanvasContext.canvas.height = this.context.canvas.height;\n    }\n\n    /**\n     * Load an image and draw it on the canvas (if an image exists)\n     * @param callbackFn A function that is called after the image loading is finished\n     * @return Emits a value when the image has been loaded.\n     */\n    private _loadImage(callbackFn?: any): void {\n        this._canDraw = false;\n\n        //If we already have the image there is no need to acquire it\n        if (this._imageElement) {\n            this._canDraw = true;\n            callbackFn && callbackFn();\n            return;\n        }\n\n        this._imageElement = new Image();\n        this._imageElement.addEventListener(\"load\", () => {\n            this._canDraw = true;\n            callbackFn && callbackFn();\n            this.onImageLoaded.emit(true);\n        });\n        this._imageElement.src = this.imageUrl;\n    }\n\n    /**\n     * Sends a notification after clearing the canvas\n     * This method should only be called from the clear button in this component since it will emit an clear event\n     * If the client calls this method he may create a circular clear action which may cause danger.\n     */\n    clearCanvasLocal(): void {\n        this.clearCanvas();\n        this.onClear.emit(true);\n    }\n\n    /**\n     * Clears all content on the canvas.\n     */\n    clearCanvas(): void {\n        this._removeCanvasData();\n        this._redoStack = [];\n    }\n\n    /**\n     * This method resets the state of the canvas and redraws it.\n     * It calls a callback function after redrawing\n     * @param callbackFn\n     */\n    private _removeCanvasData(callbackFn?: any): void {\n        this._shapesMap = new Map<string, CanvasWhiteboardShape>();\n        this._clientDragging = false;\n        this._updateHistory = [];\n        this._undoStack = [];\n        this._redrawBackground(callbackFn);\n    }\n\n    /**\n     * Clears the canvas and redraws the image if the url exists.\n     * @param callbackFn A function that is called after the background is redrawn\n     * @return Emits a value when the clearing is finished\n     */\n    private _redrawBackground(callbackFn?: any): void {\n        if (this.context) {\n            if (this.imageUrl) {\n                this._loadImage(() => {\n                    this.context.save();\n                    this._drawImage(this.context, this._imageElement, 0, 0, this.context.canvas.width, this.context.canvas.height, 0.5, 0.5);\n                    this.context.restore();\n                    this._drawMissingUpdates();\n                    callbackFn && callbackFn();\n                });\n            } else {\n                this.context.clearRect(0, 0, this.context.canvas.width, this.context.canvas.height);\n                this._drawStartingColor();\n                callbackFn && callbackFn();\n            }\n        }\n    }\n\n    private _drawStartingColor() {\n        let previousFillStyle = this.context.fillStyle;\n        this.context.save();\n\n        this.context.fillStyle = this.startingColor;\n        this.context.fillRect(0, 0, this.context.canvas.width, this.context.canvas.height);\n        this.context.fillStyle = previousFillStyle;\n\n        this.context.restore();\n    }\n\n\n    /**\n     * @deprecated Use getDrawingEnabled(): boolean\n     */\n    getShouldDraw(): boolean {\n        return this.getDrawingEnabled();\n    }\n\n    /**\n     * Returns a value of whether the user clicked the draw button on the canvas.\n     */\n    getDrawingEnabled(): boolean {\n        return this.drawingEnabled;\n    }\n\n    /**\n     * Toggles drawing on the canvas. It is called via the draw button on the canvas.\n     */\n    toggleDrawingEnabled(): void {\n        this.drawingEnabled = !this.drawingEnabled;\n    }\n\n    /**\n     * Set if drawing is enabled from the client using the canvas\n     * @param drawingEnabled\n     */\n    setDrawingEnabled(drawingEnabled: boolean): void {\n        this.drawingEnabled = drawingEnabled;\n    }\n\n    /**\n     * @deprecated Please use the changeStrokeColor(newStrokeColor: string): void method\n     */\n    changeColor(newStrokeColor: string): void {\n        this.changeStrokeColor(newStrokeColor);\n    }\n\n    /**\n     * Replaces the drawing color with a new color\n     * The format should be (\"#ffffff\" or \"rgb(r,g,b,a?)\")\n     * This method is public so that anyone can access the canvas and change the stroke color\n     *\n     * @param newStrokeColor The new stroke color\n     */\n    changeStrokeColor(newStrokeColor: string): void {\n        this.strokeColor = newStrokeColor;\n\n        this.canvasWhiteboardShapePreviewOptions = this.generateShapePreviewOptions();\n        this._changeDetector.detectChanges();\n    }\n\n    /**\n     * Replaces the fill color with a new color\n     * The format should be (\"#ffffff\" or \"rgb(r,g,b,a?)\")\n     * This method is public so that anyone can access the canvas and change the fill color\n     *\n     * @param newFillColor The new fill color\n     */\n    changeFillColor(newFillColor: string): void {\n        this.fillColor = newFillColor;\n        this.canvasWhiteboardShapePreviewOptions = this.generateShapePreviewOptions();\n        this._changeDetector.detectChanges();\n    }\n\n    /**\n     * This method is invoked by the undo button on the canvas screen\n     * It calls the global undo method and emits a notification after undoing.\n     * This method should only be called from the undo button in this component since it will emit an undo event\n     * If the client calls this method he may create a circular undo action which may cause danger.\n     */\n    undoLocal(): void {\n        this.undo((updateUUID) => {\n            this._redoStack.push(updateUUID);\n            this.onUndo.emit(updateUUID);\n        });\n    }\n\n    /**\n     * This methods selects the last uuid prepares it for undoing (making the whole update sequence invisible)\n     * This method can be called if the canvas component is a ViewChild of some other component.\n     * This method will work even if the undo button has been disabled\n     */\n    undo(callbackFn?: Function): void {\n        if (!this._undoStack.length) return;\n\n        let updateUUID = this._undoStack.pop();\n        this._undoCanvas(updateUUID);\n        callbackFn && callbackFn(updateUUID);\n    }\n\n    /**\n     * This method takes an UUID for an update, and redraws the canvas by making all updates with that uuid invisible\n     * @param updateUUID\n     */\n    private _undoCanvas(updateUUID: string): void {\n        if (this._shapesMap.has(updateUUID)) {\n            let shape = this._shapesMap.get(updateUUID);\n            shape.isVisible = false;\n            this.drawAllShapes();\n        }\n    }\n\n    /**\n     * This method is invoked by the redo button on the canvas screen\n     * It calls the global redo method and emits a notification after redoing\n     * This method should only be called from the redo button in this component since it will emit an redo event\n     * If the client calls this method he may create a circular redo action which may cause danger.\n     */\n    redoLocal(): void {\n        this.redo((updateUUID) => {\n            this._undoStack.push(updateUUID);\n            this.onRedo.emit(updateUUID);\n        });\n    }\n\n    /**\n     * This methods selects the last uuid prepares it for redoing (making the whole update sequence visible)\n     * This method can be called if the canvas component is a ViewChild of some other component.\n     * This method will work even if the redo button has been disabled\n     */\n    redo(callbackFn?: any): void {\n        if (!this._redoStack.length) return;\n\n        let updateUUID = this._redoStack.pop();\n        this._redoCanvas(updateUUID);\n        callbackFn && callbackFn(updateUUID);\n    }\n\n    /**\n     * This method takes an UUID for an update, and redraws the canvas by making all updates with that uuid visible\n     * @param updateUUID\n     */\n    private _redoCanvas(updateUUID: string): void {\n        if (this._shapesMap.has(updateUUID)) {\n            let shape = this._shapesMap.get(updateUUID);\n            shape.isVisible = true;\n\n            this.drawAllShapes();\n        }\n    }\n\n    /**\n     * Catches the Mouse and Touch events made on the canvas.\n     * If drawing is disabled (If an image exists but it's not loaded, or the user did not click Draw),\n     * this function does nothing.\n     *\n     * If a \"mousedown | touchstart\" event is triggered, dragging will be set to true and an CanvasWhiteboardUpdate object\n     * of type \"start\" will be drawn and then sent as an update to all receiving ends.\n     *\n     * If a \"mousemove | touchmove\" event is triggered and the client is dragging, an CanvasWhiteboardUpdate object\n     * of type \"drag\" will be drawn and then sent as an update to all receiving ends.\n     *\n     * If a \"mouseup, mouseout | touchend, touchcancel\" event is triggered, dragging will be set to false and\n     * an CanvasWhiteboardUpdate object of type \"stop\" will be drawn and then sent as an update to all receiving ends.\n     *\n     */\n    canvasUserEvents(event: any): void {\n        //Ignore all if we didn't click the _draw! button or the image did not load\n        if (!this.drawingEnabled || !this._canDraw) {\n            return;\n        }\n\n        // Ignore mouse move Events if we're not dragging\n        if (!this._clientDragging\n            && (event.type === 'mousemove'\n                || event.type === 'touchmove'\n                || event.type === 'mouseout'\n                || event.type === 'touchcancel'\n                || event.type === 'mouseup'\n                || event.type === 'touchend'\n                || event.type === 'mouseout')) {\n            return;\n        }\n\n        if (event.target == this._incompleteShapesCanvas.nativeElement || event.target == this.canvas.nativeElement) {\n            event.preventDefault();\n        }\n\n        let update: CanvasWhiteboardUpdate;\n        let updateType: number;\n        let eventPosition: CanvasWhiteboardPoint = this._getCanvasEventPosition(event);\n        update = new CanvasWhiteboardUpdate(eventPosition.x, eventPosition.y);\n\n        switch (event.type) {\n            case 'mousedown':\n            case 'touchstart':\n                this._clientDragging = true;\n                this._lastUUID = this._generateUUID();\n                updateType = CanvasWhiteboardUpdateType.START;\n                this._redoStack = [];\n\n                this._addCurrentShapeDataToAnUpdate(update);\n                break;\n            case 'mousemove':\n            case 'touchmove':\n                if (!this._clientDragging) {\n                    return;\n                }\n                updateType = CanvasWhiteboardUpdateType.DRAG;\n                break;\n            case 'touchcancel':\n            case 'mouseup':\n            case 'touchend':\n            case 'mouseout':\n                this._clientDragging = false;\n                updateType = CanvasWhiteboardUpdateType.STOP;\n                this._undoStack.push(this._lastUUID);\n                break;\n        }\n\n        update.UUID = this._lastUUID;\n        update.type = updateType;\n\n        this._draw(update);\n        this._prepareToSendUpdate(update);\n    }\n\n    /**\n     * Get the coordinates (x,y) from a given event\n     * If it is a touch event, get the touch positions\n     * If we released the touch, the position will be placed in the changedTouches object\n     * If it is not a touch event, use the original mouse event received\n     * @param eventData\n     */\n    private _getCanvasEventPosition(eventData: any): CanvasWhiteboardPoint {\n        let canvasBoundingRect = this.context.canvas.getBoundingClientRect();\n\n        let hasTouches = (eventData.touches && eventData.touches.length) ? eventData.touches[0] : null;\n        if (!hasTouches)\n            hasTouches = (eventData.changedTouches && eventData.changedTouches.length) ? eventData.changedTouches[0] : null;\n\n        let event = hasTouches ? hasTouches : eventData;\n\n        const scaleWidth = canvasBoundingRect.width / this.context.canvas.width;\n        const scaleHeight = canvasBoundingRect.height / this.context.canvas.height;\n\n        let xPosition = (event.clientX - canvasBoundingRect.left);\n        let yPosition = (event.clientY - canvasBoundingRect.top);\n\n        xPosition /= this.scaleFactor ? this.scaleFactor : scaleWidth;\n        yPosition /= this.scaleFactor ? this.scaleFactor : scaleHeight;\n\n        return new CanvasWhiteboardPoint(xPosition / this.context.canvas.width, yPosition / this.context.canvas.height);\n    }\n\n    /**\n     * The update coordinates on the canvas are mapped so that all receiving ends\n     * can reverse the mapping and get the same position as the one that\n     * was drawn on this update.\n     *\n     * @param update The CanvasWhiteboardUpdate object.\n     */\n    private _prepareToSendUpdate(update: CanvasWhiteboardUpdate): void {\n        this._prepareUpdateForBatchDispatch(update);\n    }\n\n\n    /**\n     * Catches the Key Up events made on the canvas.\n     * If the ctrlKey or commandKey(macOS) was held and the keyCode is 90 (z), an undo action will be performed\n     * If the ctrlKey or commandKey(macOS) was held and the keyCode is 89 (y), a redo action will be performed\n     * If the ctrlKey or commandKey(macOS) was held and the keyCode is 83 (s) or 115(S), a save action will be performed\n     *\n     * @param event The event that occurred.\n     */\n    private _canvasKeyDown(event: any): void {\n        if (event.ctrlKey || event.metaKey) {\n            if (event.keyCode === 90 && this.undoButtonEnabled) {\n                event.preventDefault();\n                this.undo();\n            }\n            if (event.keyCode === 89 && this.redoButtonEnabled) {\n                event.preventDefault();\n                this.redo();\n            }\n            if (event.keyCode === 83 || event.keyCode === 115) {\n                event.preventDefault();\n                this.saveLocal();\n            }\n        }\n    }\n\n    /**\n     * On window resize, recalculate the canvas dimensions and redraw the history\n     */\n    private _redrawCanvasOnResize(): void {\n        this._calculateCanvasWidthAndHeight();\n        this._redrawHistory();\n    }\n\n    /**\n     * Redraw the saved history after resetting the canvas state\n     */\n    private _redrawHistory(): void {\n        let updatesToDraw = [].concat(this._updateHistory);\n\n        this._removeCanvasData(() => {\n            updatesToDraw.forEach((update: CanvasWhiteboardUpdate) => {\n                this._draw(update);\n            });\n        });\n    }\n\n    /**\n     * Draws a CanvasWhiteboardUpdate object on the canvas.\n     * The coordinates are first reverse mapped so that they can be drawn in the proper place. The update\n     * is afterwards added to the undoStack so that it can be\n     *\n     * If the CanvasWhiteboardUpdate Type is \"start\", a new \"selectedShape\" is created.\n     * If the CanvasWhiteboardUpdate Type is \"drag\", the shape is taken from the shapesMap and then it's updated.\n     * Afterwards the context is used to draw the shape on the canvas.\n     * This function saves the last X and Y coordinates that were drawn.\n     *\n     * @param update The update object.\n     */\n    private _draw(update: CanvasWhiteboardUpdate): void {\n        this._updateHistory.push(update);\n\n        //map the canvas coordinates to our canvas size since they are scaled.\n        update = Object.assign(new CanvasWhiteboardUpdate(),\n            update,\n            {\n                x: update.x * this.context.canvas.width,\n                y: update.y * this.context.canvas.height\n            });\n\n        if (update.type === CanvasWhiteboardUpdateType.START) {\n            let updateShapeConstructor = this._canvasWhiteboardShapeService.getShapeConstructorFromShapeName(update.selectedShape);\n            let shape = new updateShapeConstructor(\n                new CanvasWhiteboardPoint(update.x, update.y),\n                Object.assign(new CanvasWhiteboardShapeOptions(), update.selectedShapeOptions)\n            );\n            this._incompleteShapesMap.set(update.UUID, shape);\n            this._drawIncompleteShapes();\n        } else if (update.type === CanvasWhiteboardUpdateType.DRAG) {\n            let shape = this._incompleteShapesMap.get(update.UUID);\n            shape && shape.onUpdateReceived(update);\n            this._drawIncompleteShapes();\n        } else if (CanvasWhiteboardUpdateType.STOP) {\n            let shape = this._incompleteShapesMap.get(update.UUID);\n            shape && shape.onStopReceived(update);\n\n            this._shapesMap.set(update.UUID, shape);\n            this._incompleteShapesMap.delete(update.UUID);\n            this._swapCompletedShapeToActualCanvas(shape);\n        }\n    }\n\n    private _drawIncompleteShapes() {\n        this._resetIncompleteShapeCanvas();\n        this._incompleteShapesMap.forEach((shape) => {\n            if (shape.isVisible) {\n                shape.draw(this._incompleteShapesCanvasContext);\n            }\n        });\n    }\n\n    private _swapCompletedShapeToActualCanvas(shape: CanvasWhiteboardShape) {\n        this._drawIncompleteShapes();\n        if (shape.isVisible) {\n            shape.draw(this.context);\n        }\n    }\n\n    private _resetIncompleteShapeCanvas() {\n        this._incompleteShapesCanvasContext.clearRect(0, 0, this._incompleteShapesCanvasContext.canvas.width, this._incompleteShapesCanvasContext.canvas.height);\n        this._incompleteShapesCanvasContext.fillStyle = \"transparent\";\n        this._incompleteShapesCanvasContext.fillRect(0, 0, this._incompleteShapesCanvasContext.canvas.width, this._incompleteShapesCanvasContext.canvas.height);\n    }\n\n    /**\n     * Delete everything from the screen, redraw the background, and then redraw all the shapes from the shapesMap\n     */\n    drawAllShapes() {\n        this._redrawBackground(() => {\n            this._shapesMap.forEach((shape: CanvasWhiteboardShape) => {\n                if (shape.isVisible) {\n                    shape.draw(this.context);\n                }\n            });\n        });\n    }\n\n    private _addCurrentShapeDataToAnUpdate(update: CanvasWhiteboardUpdate) {\n        if (!update.selectedShape) {\n            update.selectedShape = (new this.selectedShapeConstructor).getShapeName();\n        }\n\n        if (!update.selectedShapeOptions) {\n            //Make a deep copy since we don't want some Shape implementation to change something by accident\n            update.selectedShapeOptions = Object.assign(new CanvasWhiteboardShapeOptions(), this.generateShapePreviewOptions(), {lineWidth: this.lineWidth});\n        }\n    }\n\n    generateShapePreviewOptions(): CanvasWhiteboardShapeOptions {\n        return Object.assign(new CanvasWhiteboardShapeOptions(),\n            {\n                shouldFillShape: !!this.fillColor,\n                fillStyle: this.fillColor,\n                strokeStyle: this.strokeColor,\n                lineWidth: 2,\n                lineJoin: this.lineJoin,\n                lineCap: this.lineCap\n            });\n    }\n\n    /**\n     * Sends the update to all receiving ends as an Event emit. This is done as a batch operation (meaning\n     * multiple updates are sent at the same time). If this method is called, after 100 ms all updates\n     * that were made at that time will be packed up together and sent to the receiver.\n     *\n     * @param update The update object.\n     * @return Emits an Array of Updates when the batch.\n     */\n    private _prepareUpdateForBatchDispatch(update: CanvasWhiteboardUpdate): void {\n        this._batchUpdates.push(cloneDeep(update));\n        if (!this._updateTimeout) {\n            this._updateTimeout = setTimeout(() => {\n                this.onBatchUpdate.emit(this._batchUpdates);\n                this._batchUpdates = [];\n                this._updateTimeout = null;\n            }, this.batchUpdateTimeoutDuration);\n        }\n    };\n\n    /**\n     * Draws an Array of Updates on the canvas.\n     *\n     * @param updates The array with Updates.\n     */\n    drawUpdates(updates: CanvasWhiteboardUpdate[]): void {\n        if (this._canDraw) {\n            this._drawMissingUpdates();\n            updates.forEach((update: CanvasWhiteboardUpdate) => {\n                this._draw(update);\n            });\n        } else {\n            this._updatesNotDrawn = this._updatesNotDrawn.concat(updates);\n        }\n    };\n\n    /**\n     * Draw any missing updates that were received before the image was loaded\n     */\n    private _drawMissingUpdates(): void {\n        if (this._updatesNotDrawn.length > 0) {\n            let updatesToDraw = this._updatesNotDrawn;\n            this._updatesNotDrawn = [];\n\n            updatesToDraw.forEach((update: CanvasWhiteboardUpdate) => {\n                this._draw(update);\n            });\n        }\n    }\n\n    /**\n     * Draws an image on the canvas\n     *\n     * @param context The context used to draw the image on the canvas.\n     * @param image The image to draw.\n     * @param x The X coordinate for the starting draw position.\n     * @param y The Y coordinate for the starting draw position.\n     * @param width The width of the image that will be drawn.\n     * @param height The height of the image that will be drawn.\n     * @param offsetX The offsetX if the image size is larger than the canvas (aspect Ratio)\n     * @param offsetY The offsetY if the image size is larger than the canvas (aspect Ratio)\n     */\n    private _drawImage(context: any, image: any, x: number, y: number, width: number, height: number, offsetX: number, offsetY: number): void {\n        if (arguments.length === 2) {\n            x = y = 0;\n            width = context.canvas.width;\n            height = context.canvas.height;\n        }\n\n        offsetX = typeof offsetX === 'number' ? offsetX : 0.5;\n        offsetY = typeof offsetY === 'number' ? offsetY : 0.5;\n\n        if (offsetX < 0) offsetX = 0;\n        if (offsetY < 0) offsetY = 0;\n        if (offsetX > 1) offsetX = 1;\n        if (offsetY > 1) offsetY = 1;\n\n        let imageWidth = image.width;\n        let imageHeight = image.height;\n        let radius = Math.min(width / imageWidth, height / imageHeight);\n        let newWidth = imageWidth * radius;\n        let newHeight = imageHeight * radius;\n        let finalDrawX: any;\n        let finalDrawY: any;\n        let finalDrawWidth: any;\n        let finalDrawHeight: any;\n        let aspectRatio = 1;\n\n        // decide which gap to fill\n        if (newWidth < width) aspectRatio = width / newWidth;\n        if (Math.abs(aspectRatio - 1) < 1e-14 && newHeight < height) aspectRatio = height / newHeight;\n        newWidth *= aspectRatio;\n        newHeight *= aspectRatio;\n\n        // calculate source rectangle\n        finalDrawWidth = imageWidth / (newWidth / width);\n        finalDrawHeight = imageHeight / (newHeight / height);\n\n        finalDrawX = (imageWidth - finalDrawWidth) * offsetX;\n        finalDrawY = (imageHeight - finalDrawHeight) * offsetY;\n\n        // make sure the source rectangle is valid\n        if (finalDrawX < 0) finalDrawX = 0;\n        if (finalDrawY < 0) finalDrawY = 0;\n        if (finalDrawWidth > imageWidth) finalDrawWidth = imageWidth;\n        if (finalDrawHeight > imageHeight) finalDrawHeight = imageHeight;\n\n        // fill the image in destination rectangle\n        context.drawImage(image, finalDrawX, finalDrawY, finalDrawWidth, finalDrawHeight, x, y, width, height);\n    }\n\n    /**\n     * The HTMLCanvasElement.toDataURL() method returns a data URI containing a representation of the image in the format specified by the type parameter (defaults to PNG).\n     * The returned image is in a resolution of 96 dpi.\n     * If the height or width of the canvas is 0, the string \"data:,\" is returned.\n     * If the requested type is not image/png, but the returned value starts with data:image/png, then the requested type is not supported.\n     * Chrome also supports the image/webp type.\n     *\n     * @param returnedDataType A DOMString indicating the image format. The default format type is image/png.\n     * @param returnedDataQuality A Number between 0 and 1 indicating image quality if the requested type is image/jpeg or image/webp.\n     If this argument is anything else, the default value for image quality is used. The default value is 0.92. Other arguments are ignored.\n     */\n    generateCanvasDataUrl(returnedDataType: string = \"image/png\", returnedDataQuality: number = 1): string {\n        return this.context.canvas.toDataURL(returnedDataType, returnedDataQuality);\n    }\n\n    /**\n     * Generate a Blob object representing the content drawn on the canvas.\n     * This file may be cached on the disk or stored in memory at the discretion of the user agent.\n     * If type is not specified, the image type is image/png. The created image is in a resolution of 96dpi.\n     * The third argument is used with image/jpeg images to specify the quality of the output.\n     *\n     * @param callbackFn The function that should be executed when the blob is created. Should accept a parameter Blob (for the result).\n     * @param returnedDataType A DOMString indicating the image format. The default type is image/png.\n     * @param returnedDataQuality A Number between 0 and 1 indicating image quality if the requested type is image/jpeg or image/webp.\n     If this argument is anything else, the default value for image quality is used. Other arguments are ignored.\n     */\n    generateCanvasBlob(callbackFn: any, returnedDataType: string = \"image/png\", returnedDataQuality: number = 1): void {\n        let toBlobMethod: Function;\n\n        if (typeof this.context.canvas.toBlob !== \"undefined\") {\n            toBlobMethod = this.context.canvas.toBlob.bind(this.context.canvas);\n        } else if (typeof (this.context.canvas as any).msToBlob !== \"undefined\") {\n            // For IE\n            toBlobMethod = (callback) => {\n                callback && callback((this.context.canvas as any).msToBlob());\n            };\n        }\n\n        toBlobMethod && toBlobMethod((blob: Blob) => {\n            callbackFn && callbackFn(blob, returnedDataType);\n        }, returnedDataType, returnedDataQuality);\n    }\n\n    /**\n     * Generate a canvas image representation and download it locally\n     * The name of the image is canvas_drawing_ + the current local Date and Time the image was created\n     * Methods for standalone creation of the images in this method are left here for backwards compatibility\n     *\n     * @param returnedDataType A DOMString indicating the image format. The default type is image/png.\n     * @param downloadData? The created string or Blob (IE).\n     * @param customFileName? The name of the file that should be downloaded\n     */\n    downloadCanvasImage(returnedDataType: string = \"image/png\", downloadData?: string | Blob, customFileName?: string): void {\n        if (window.navigator.msSaveOrOpenBlob === undefined) {\n            let downloadLink = document.createElement('a');\n            downloadLink.setAttribute('href', downloadData ? <string>downloadData : this.generateCanvasDataUrl(returnedDataType));\n\n            let fileName = customFileName ? customFileName\n                : (this.downloadedFileName ? this.downloadedFileName : \"canvas_drawing_\" + new Date().valueOf());\n\n            downloadLink.setAttribute('download', fileName + this._generateDataTypeString(returnedDataType));\n            document.body.appendChild(downloadLink);\n            downloadLink.click();\n            document.body.removeChild(downloadLink);\n        } else {\n            // IE-specific code\n            if (downloadData) {\n                this._saveCanvasBlob(<Blob>downloadData, returnedDataType);\n            } else {\n                this.generateCanvasBlob(this._saveCanvasBlob.bind(this), returnedDataType);\n            }\n        }\n    }\n\n    /**\n     * Save the canvas blob (IE) locally\n     * @param blob\n     * @param returnedDataType\n     */\n    private _saveCanvasBlob(blob: Blob, returnedDataType: string = \"image/png\"): void {\n        window.navigator.msSaveOrOpenBlob(blob, \"canvas_drawing_\" + new Date().valueOf() + this._generateDataTypeString(returnedDataType));\n    }\n\n    /**\n     * This method generates a canvas url string or a canvas blob with the presented data type\n     * A callback function is then invoked since the blob creation must be done via a callback\n     *\n     * @param callback\n     * @param returnedDataType\n     * @param returnedDataQuality\n     */\n    generateCanvasData(callback: any, returnedDataType: string = \"image/png\", returnedDataQuality: number = 1): void {\n        if (window.navigator.msSaveOrOpenBlob === undefined) {\n            callback && callback(this.generateCanvasDataUrl(returnedDataType, returnedDataQuality))\n        } else {\n            this.generateCanvasBlob(callback, returnedDataType, returnedDataQuality);\n        }\n    }\n\n    /**\n     * Local method to invoke saving of the canvas data when clicked on the canvas Save button\n     * This method will emit the generated data with the specified Event Emitter\n     *\n     * @param returnedDataType\n     */\n    saveLocal(returnedDataType: string = \"image/png\"): void {\n        this.generateCanvasData((generatedData: string | Blob) => {\n            this.onSave.emit(generatedData);\n\n            if (this.shouldDownloadDrawing) {\n                this.downloadCanvasImage(returnedDataType, generatedData);\n            }\n        });\n    }\n\n    private _generateDataTypeString(returnedDataType: string): string {\n        if (returnedDataType) {\n            return \".\" + returnedDataType.split('/')[1];\n        }\n\n        return \"\";\n    }\n\n    /**\n     * Toggles the color picker window, delegating the showColorPicker Input to the ColorPickerComponent.\n     * If no value is supplied (null/undefined) the current value will be negated and used.\n     * @param value\n     */\n    toggleStrokeColorPicker(value: boolean) {\n        this.showStrokeColorPicker = !this._isNullOrUndefined(value) ? value : !this.showStrokeColorPicker;\n    }\n\n    /**\n     * Toggles the color picker window, delegating the showColorPicker Input to the ColorPickerComponent.\n     * If no value is supplied (null/undefined) the current value will be negated and used.\n     * @param value\n     */\n    toggleFillColorPicker(value: boolean) {\n        this.showFillColorPicker = !this._isNullOrUndefined(value) ? value : !this.showFillColorPicker;\n    }\n\n    /**\n     * Toggles the shape selector window, delegating the showShapeSelector Input to the CanvasWhiteboardShapeSelectorComponent.\n     * If no value is supplied (null/undefined) the current value will be negated and used.\n     * @param value\n     */\n    toggleShapeSelector(value: boolean) {\n        this.showShapeSelector = !this._isNullOrUndefined(value) ? value : !this.showShapeSelector;\n    }\n\n    selectShape(newShapeBlueprint: INewCanvasWhiteboardShape<CanvasWhiteboardShape>) {\n        this.selectedShapeConstructor = newShapeBlueprint;\n    }\n\n    /**\n     * Returns a deep copy of the current drawing history for the canvas.\n     * The deep copy is returned because we don't want anyone to mutate the current history\n     */\n    getDrawingHistory(): CanvasWhiteboardUpdate[] {\n        return cloneDeep(this._updateHistory);\n    }\n\n    /**\n     * Unsubscribe from a given subscription if it is active\n     * @param subscription\n     */\n    private _unsubscribe(subscription: Subscription): void {\n        if (subscription) subscription.unsubscribe();\n    }\n\n    private _generateUUID(): string {\n        return this._random4() + this._random4() + \"-\" + this._random4() + \"-\" + this._random4() + \"-\" +\n            this._random4() + \"-\" + this._random4() + this._random4() + this._random4();\n    }\n\n    private _random4(): string {\n        return Math.floor((1 + Math.random()) * 0x10000)\n            .toString(16)\n            .substring(1);\n    }\n\n    /**\n     * Unsubscribe from the service observables\n     */\n    ngOnDestroy(): void {\n        this._unsubscribe(this._resizeSubscription);\n        this._unsubscribe(this._registeredShapesSubscription);\n        this._canvasWhiteboardServiceSubscriptions.forEach(subscription => this._unsubscribe(subscription));\n    }\n}\n","import {\n    Component,\n    ElementRef,\n    EventEmitter,\n    Input,\n    Output\n} from \"@angular/core\";\nimport {CanvasWhiteboardShapeService, INewCanvasWhiteboardShape} from \"./canvas-whiteboard-shape.service\";\nimport {CanvasWhiteboardShape} from \"./canvas-whiteboard-shape\";\nimport {CanvasWhiteboardShapeOptions} from \"./canvas-whiteboard-shape-options\";\nimport {Observable} from \"rxjs\";\n\n@Component({\n    selector: \"canvas-whiteboard-shape-selector\",\n    host: {\n        '(document:mousedown)': 'closeOnExternalClick($event)',\n        '(document:touchstart)': 'closeOnExternalClick($event)',\n    },\n    template: `\n        <div *ngIf=\"!showShapeSelector\" (click)=\"toggleShapeSelector($event)\"\n             class=\"canvas-whiteboard-shape-selector-selected-preview\">\n            <canvas-whiteboard-shape-preview [shapeConstructor]=\"selectedShapeConstructor\"\n                                             [shapeOptions]=\"shapeOptions\"></canvas-whiteboard-shape-preview>\n        </div>\n        <div class=\"canvas-whiteboard-shape-selector-wrapper\" *ngIf=\"showShapeSelector\">\n            <canvas-whiteboard-shape-preview *ngFor=\"let shapeConstructor of registeredShapes$ | async\"\n                                             [shapeConstructor]=\"shapeConstructor\"\n                                             [shapeOptions]=\"shapeOptions\"\n                                             (click)=\"selectShape(shapeConstructor)\"></canvas-whiteboard-shape-preview>\n        </div>\n    `,\n    styles: [`\n        .canvas-whiteboard-shape-selector-selected-preview {\n            vertical-align: bottom;\n            display: inline-block;\n        }\n\n        .canvas-whiteboard-shape-selector-wrapper {\n            display: block;\n            padding: 4px;\n            border: 1px solid #afafaf;\n        }\n\n        @media (min-width: 401px) {\n            .canvas-whiteboard-shape-selector-wrapper {\n            }\n        }\n    `]\n})\nexport class CanvasWhiteboardShapeSelectorComponent {\n    @Input() readonly showShapeSelector: boolean = false;\n    @Input() readonly selectedShapeConstructor: INewCanvasWhiteboardShape<CanvasWhiteboardShape>;\n    @Input() readonly shapeOptions: CanvasWhiteboardShapeOptions;\n\n    @Output() onToggleShapeSelector = new EventEmitter<boolean>();\n    @Output() onShapeSelected = new EventEmitter<INewCanvasWhiteboardShape<CanvasWhiteboardShape>>();\n\n    registeredShapes$: Observable<INewCanvasWhiteboardShape<CanvasWhiteboardShape>[]>;\n\n    constructor(private _elementRef: ElementRef,\n                private _canvasWhiteboardShapeService: CanvasWhiteboardShapeService) {\n        this.registeredShapes$ = this._canvasWhiteboardShapeService.registeredShapes$;\n    }\n\n    selectShape(shape: INewCanvasWhiteboardShape<CanvasWhiteboardShape>) {\n        this.onShapeSelected.emit(shape);\n        this.toggleShapeSelector(null);\n    }\n\n    closeOnExternalClick(event) {\n        if (!this._elementRef.nativeElement.contains(event.target) && this.showShapeSelector) {\n            this.onToggleShapeSelector.emit(false);\n        }\n    }\n\n    toggleShapeSelector(event: Event) {\n        if (event) {\n            event.preventDefault();\n        }\n\n        this.onToggleShapeSelector.emit(!this.showShapeSelector);\n    }\n}\n","import {\n    Component,\n    Output,\n    EventEmitter, OnInit, ViewChild, ElementRef, Input\n} from '@angular/core';\n\n@Component({\n    selector: 'canvas-whiteboard-colorpicker',\n    host: {\n        '(document:mousedown)': 'closeOnExternalClick($event)',\n        '(document:touchstart)': 'closeOnExternalClick($event)',\n    },\n    template: `\n        <div [hidden]=\"showColorPicker\" class=\"canvas-whiteboard-colorpicker-input\"\n               (click)=\"toggleColorPicker($event)\">\n               <div class=\"selected-color-type-wrapper\">{{previewText}}</div>\n               <div class=\"selected-color-preview\" [style.background]=\"selectedColor\"></div>\n        </div>\n        <div [hidden]=\"!showColorPicker\" class=\"canvas-whiteboard-colorpicker-wrapper\">\n            <div (click)=\"selectColor('transparent')\" class=\"transparent-color\">Transparent</div>\n            <canvas #canvaswhiteboardcolorpicker class=\"canvas-whiteboard-colorpicker\" width=\"284\" height=\"155\"\n                    (click)=\"selectColor(determineColorFromCanvas($event))\"></canvas>\n        </div>\n    `,\n    styles: [`\n        .selected-color-preview {\n            width: 100%;\n            height: 20%;\n            position: absolute;\n            bottom: 0;\n            left: 0;\n        }\n        \n        .selected-color-type-wrapper {\n            display: inline-block;\n            height: 100%;\n            width: 100%;\n            text-align: center;\n            font-size: 14px;\n            color: #000;\n        }\n        \n        .transparent-color {\n            font-size: 14px;\n        }\n        \n        .canvas-whiteboard-colorpicker-wrapper {\n            border: 1px solid #afafaf;\n            color: #000;\n        }\n\n        @media (min-width: 401px) {\n            .canvas-whiteboard-colorpicker-wrapper {\n                position: absolute;\n            }\n        }\n\n        .canvas-whiteboard-colorpicker-input {\n            display: inline-block;\n            position:relative;\n            width: 44px;\n            height: 44px;\n            margin: 5px;\n            cursor: pointer;\n            color: #000;\n        }\n    `]\n})\nexport class CanvasWhiteboardColorPickerComponent implements OnInit {\n\n    @Input() previewText: string;\n    @Input() readonly selectedColor: string = 'rgba(0,0,0,1)';\n    @ViewChild('canvaswhiteboardcolorpicker', { static: true }) canvas: ElementRef;\n\n    @Input() readonly showColorPicker: boolean = false;\n    private _context: CanvasRenderingContext2D;\n\n    @Output() onToggleColorPicker = new EventEmitter<boolean>();\n    @Output() onColorSelected = new EventEmitter<string>();\n    @Output() onSecondaryColorSelected = new EventEmitter<string>();\n\n    constructor(private _elementRef: ElementRef) {\n    }\n\n    /**\n     * Initialize the canvas drawing context. If we have an aspect ratio set up, the canvas will resize\n     * according to the aspect ratio.\n     */\n    ngOnInit() {\n        this._context = this.canvas.nativeElement.getContext(\"2d\");\n        this.createColorPalette();\n    }\n\n    createColorPalette() {\n        let gradient = this._context.createLinearGradient(0, 0, this._context.canvas.width, 0);\n        gradient.addColorStop(0, \"rgb(255, 0, 0)\");\n        gradient.addColorStop(0.15, \"rgb(255, 0, 255)\");\n        gradient.addColorStop(0.33, \"rgb(0, 0, 255)\");\n        gradient.addColorStop(0.49, \"rgb(0, 255, 255)\");\n        gradient.addColorStop(0.67, \"rgb(0, 255, 0)\");\n        gradient.addColorStop(0.84, \"rgb(255, 255, 0)\");\n        gradient.addColorStop(1, \"rgb(255, 0, 0)\");\n        this._context.fillStyle = gradient;\n        this._context.fillRect(0, 0, this._context.canvas.width, this._context.canvas.height);\n\n        gradient = this._context.createLinearGradient(0, 0, 0, this._context.canvas.height);\n        gradient.addColorStop(0, \"rgba(255, 255, 255, 1)\");\n        gradient.addColorStop(0.5, \"rgba(255, 255, 255, 0)\");\n        gradient.addColorStop(0.5, \"rgba(0, 0, 0, 0)\");\n        gradient.addColorStop(1, \"rgba(0, 0, 0, 1)\");\n        this._context.fillStyle = gradient;\n        this._context.fillRect(0, 0, this._context.canvas.width, this._context.canvas.height);\n    }\n\n    closeOnExternalClick(event) {\n        if (!this._elementRef.nativeElement.contains(event.target) && this.showColorPicker) {\n            this.onToggleColorPicker.emit(false);\n        }\n    }\n\n    toggleColorPicker(event: Event) {\n        if (event) {\n            event.preventDefault();\n        }\n\n        this.onToggleColorPicker.emit(!this.showColorPicker);\n    }\n\n    determineColorFromCanvas(event: any) {\n        let canvasRect = this._context.canvas.getBoundingClientRect();\n        let imageData = this._context.getImageData(event.clientX - canvasRect.left, event.clientY - canvasRect.top, 1, 1);\n\n        return `rgba(${imageData.data[0]}, ${imageData.data[1]}, ${imageData.data[2]}, ${imageData.data[3]})`;\n    }\n\n    selectColor(color: string) {\n        this.onColorSelected.emit(color);\n        this.toggleColorPicker(null);\n    }\n}\n","import {\n    Component,\n    ElementRef,\n    Input,\n    ViewChild,\n    AfterViewInit,\n    OnChanges,\n    SimpleChanges\n} from \"@angular/core\";\nimport {INewCanvasWhiteboardShape} from \"./canvas-whiteboard-shape.service\";\nimport {CanvasWhiteboardShape} from \"./canvas-whiteboard-shape\";\nimport {CanvasWhiteboardPoint} from \"../canvas-whiteboard-point\";\nimport {CanvasWhiteboardShapeOptions} from \"./canvas-whiteboard-shape-options\";\n\n@Component({\n    selector: \"canvas-whiteboard-shape-preview\",\n    template: `\n        <canvas #canvasWhiteboardShapePreview width=\"50px\" height=\"50px\"\n                class=\"canvas-whiteboard-shape-preview-canvas\"></canvas>\n    `,\n    styles: [`\n        .canvas-whiteboard-shape-preview-canvas {\n            cursor: pointer;\n        }\n    `]\n})\nexport class CanvasWhiteboardShapePreviewComponent implements AfterViewInit, OnChanges {\n    @Input() readonly shapeConstructor: INewCanvasWhiteboardShape<CanvasWhiteboardShape>;\n    @Input() readonly shapeOptions: CanvasWhiteboardShapeOptions;\n\n    @ViewChild('canvasWhiteboardShapePreview') canvas: ElementRef;\n\n    ngAfterViewInit() {\n        this.drawShapePreview();\n    }\n\n    ngOnChanges(changes: SimpleChanges) {\n        if (changes.shapeConstructor || changes.shapeOptions) {\n            this.drawShapePreview();\n        }\n    }\n\n    drawShapePreview() {\n        if (!this.canvas) { return; }\n\n        let context: CanvasRenderingContext2D = this.canvas.nativeElement.getContext(\"2d\");\n        context.clearRect(0, 0, context.canvas.width, context.canvas.height);\n\n        let concreteShape = new this.shapeConstructor(\n            new CanvasWhiteboardPoint(0, 0),\n            Object.assign(new CanvasWhiteboardShapeOptions(), this.shapeOptions)\n        );\n\n        concreteShape.drawPreview(context);\n    }\n}\n","import {NgModule} from \"@angular/core\";\nimport {CanvasWhiteboardComponent} from \"./canvas-whiteboard.component\";\nimport {CommonModule} from \"@angular/common\";\nimport {CanvasWhiteboardColorPickerComponent} from \"./canvas-whiteboard-colorpicker.component\";\nimport {CanvasWhiteboardService} from \"./canvas-whiteboard.service\";\nimport {CanvasWhiteboardShapeService} from \"./shapes/canvas-whiteboard-shape.service\";\nimport {CanvasWhiteboardShapeSelectorComponent} from \"./shapes/canvas-whiteboard-shape-selector.component\";\nimport {CanvasWhiteboardShapePreviewComponent} from \"./shapes/canvas-whiteboard-shape-preview.component\";\n\n@NgModule({\n    imports: [\n        CommonModule\n    ],\n    declarations: [\n        CanvasWhiteboardComponent,\n        CanvasWhiteboardColorPickerComponent,\n        CanvasWhiteboardShapeSelectorComponent,\n        CanvasWhiteboardShapePreviewComponent\n    ],\n    providers: [\n        CanvasWhiteboardService,\n        CanvasWhiteboardShapeService\n    ],\n    exports: [CanvasWhiteboardComponent]\n})\nexport class CanvasWhiteboardModule {\n}\n","import {CanvasWhiteboardShapeOptions} from \"./shapes/canvas-whiteboard-shape-options\";\n\nexport enum CanvasWhiteboardUpdateType {\n    START = 0,\n    DRAG = 1,\n    STOP = 2\n}\n\nexport class CanvasWhiteboardUpdate {\n    x: number;\n    y: number;\n    type: CanvasWhiteboardUpdateType;\n    UUID: string;\n\n    selectedShape: string;\n    selectedShapeOptions: CanvasWhiteboardShapeOptions;\n\n    static deserializeJson(json: any): CanvasWhiteboardUpdate {\n        let parsedJson;\n        try {\n            parsedJson = JSON.parse(json);\n            return new CanvasWhiteboardUpdate(\n                parsedJson['x'],\n                parsedJson['y'],\n                parsedJson['type'],\n                parsedJson['uuid'],\n                parsedJson['selectedShape'],\n                parsedJson['selectedShapeOptions']);\n        } catch (e) {\n            console.error(\"The canvas whiteboard update is not p1\" +\n                \"arseable\");\n            return null;\n        }\n    }\n\n    constructor(x?: number,\n                y?: number,\n                type?: CanvasWhiteboardUpdateType,\n                UUID?: string,\n                selectedShape?: string,\n                selectedShapeOptions?: CanvasWhiteboardShapeOptions) {\n        this.x = x;\n        this.y = y;\n        this.type = type;\n        this.UUID = UUID;\n        this.selectedShape = selectedShape;\n        this.selectedShapeOptions = selectedShapeOptions;\n    }\n\n    stringify(): string {\n        let objectToSerialize = {\n            x: this.x.toFixed(3),\n            y: this.y.toFixed(3),\n            type: this.type,\n            uuid: this.UUID,\n            selectedShape: this.selectedShape\n        };\n\n        if (this.selectedShapeOptions) {\n            objectToSerialize[\"selectedShapeOptions\"] = this.selectedShapeOptions;\n        }\n\n        return JSON.stringify(objectToSerialize);\n    }\n}\n","export const DEFAULT_STYLES = `\n.canvas_whiteboard_button {\n    display: inline-block;\n    outline: 0px;\n    padding-top: 7px;\n    margin-bottom: 0;\n    font-size: 14px;\n    font-weight: 400;\n    line-height: 1.42857143;\n    text-align: center;\n    white-space: nowrap;\n    vertical-align: middle;\n    -ms-touch-action: manipulation;\n    touch-action: manipulation;\n    cursor: pointer;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n    background-image: none;\n    border: 1px solid transparent;\n    border-radius: 4px;\n}\n\n.canvas_whiteboard_buttons { \n    z-index: 3;\n}\n\n@media (max-width: 400px) {\n     .canvas_whiteboard_buttons {\n            position: absolute;\n            z-inde\n            top: 0;\n            width: 100%;\n            text-align: center;\n      }\n}\n        \n@media (min-width: 401px) { \n    .canvas_whiteboard_buttons {\n        position: absolute;\n        right: 0%;\n        color: #fff;\n    }\n}\n\n.canvas_whiteboard_buttons {\n    padding: 5px;\n}\n\n.canvas_whiteboard_buttons > button {\n    margin: 5px;\n}\n\n.canvas_whiteboard_button-draw_animated {\n    -webkit-animation: pulsate 1s ease-out;\n    -webkit-animation-iteration-count: infinite;\n}\n\n@-webkit-keyframes pulsate {\n    0% {\n        -webkit-transform: scale(0.1, 0.1);\n        opacity: 0.0;\n    }\n    50% {\n        opacity: 1.0;\n    }\n    100% {\n        -webkit-transform: scale(1.2, 1.2);\n        opacity: 0.0;\n    }\n}\n.canvas_wrapper_div {\n    width: 100%;\n    height: 100%;\n    border: 0.5px solid #e2e2e2;\n}\n\n.canvas_whiteboard_button-clear {\n    padding-top: 5px;\n}\n\n.canvas_whiteboard {\n    position: absolute;\n    z-index: 1;\n}\n\n.incomplete_shapes_canvas_whiteboard {\n    position: absolute;\n    z-index: 2;\n}\n\n`;","import {CanvasWhiteboardUpdate} from \"./canvas-whiteboard-update.model\";\nimport {Observable, Subject} from \"rxjs\";\n\nexport class CanvasWhiteboardService {\n    private _canvasDrawSubject: Subject<CanvasWhiteboardUpdate[]> = new Subject();\n    canvasDrawSubject$: Observable<CanvasWhiteboardUpdate[]> = this._canvasDrawSubject.asObservable();\n\n    private _canvasClearSubject: Subject<any> = new Subject();\n    canvasClearSubject$: Observable<any> = this._canvasClearSubject.asObservable();\n\n    private _canvasUndoSubject: Subject<any> = new Subject();\n    canvasUndoSubject$: Observable<any> = this._canvasUndoSubject.asObservable();\n\n    private _canvasRedoSubject: Subject<any> = new Subject();\n    canvasRedoSubject$: Observable<any> = this._canvasRedoSubject.asObservable();\n\n    public drawCanvas(updates: CanvasWhiteboardUpdate[]): void {\n        this._canvasDrawSubject.next(updates);\n    }\n\n    public clearCanvas(): void {\n        this._canvasClearSubject.next();\n    }\n\n    public undoCanvas(updateUUD: string): void {\n        this._canvasUndoSubject.next(updateUUD);\n    }\n\n    public redoCanvas(updateUUD: string): void {\n        this._canvasRedoSubject.next(updateUUD);\n    }\n}\n","export class CanvasWhiteboardPoint {\n    x: number;\n    y: number;\n\n    constructor(x: number, y: number) {\n        this.x = x;\n        this.y = y;\n    }\n}","export class CanvasWhiteboardShapeOptions {\n    shouldFillShape?: boolean;\n    fillStyle?: string;\n    strokeStyle?: string;\n    lineWidth?: number;\n    lineJoin?: string;\n    lineCap?: string;\n\n    constructor() {\n        this.shouldFillShape = false;\n        this.fillStyle = null;\n        this.strokeStyle = \"rgba(0,0,0,1)\";\n        this.lineWidth = 2;\n        this.lineJoin = \"round\";\n        this.lineCap = \"round\";\n    }\n}\n","import {CanvasWhiteboardShapeOptions} from \"./canvas-whiteboard-shape-options\";\nimport {CanvasWhiteboardPoint} from \"../canvas-whiteboard-point\";\nimport {CanvasWhiteboardUpdate} from \"../canvas-whiteboard-update.model\";\n\nexport abstract class CanvasWhiteboardShape {\n    isVisible: boolean;\n    protected positionPoint: CanvasWhiteboardPoint;\n    protected options: CanvasWhiteboardShapeOptions;\n\n    constructor(positionPoint?: CanvasWhiteboardPoint, options?: CanvasWhiteboardShapeOptions) {\n        this.positionPoint = positionPoint || new CanvasWhiteboardPoint(0, 0);\n        this.options = options || new CanvasWhiteboardShapeOptions();\n        this.isVisible = true;\n    }\n\n    abstract getShapeName(): string;\n\n    abstract onUpdateReceived(update: CanvasWhiteboardUpdate);\n\n    // noinspection TsLint\n    onStopReceived(update: CanvasWhiteboardUpdate) {\n    }\n\n    abstract draw(context: CanvasRenderingContext2D);\n\n    abstract drawPreview(context: CanvasRenderingContext2D);\n}","import {CanvasWhiteboardShape} from \"./canvas-whiteboard-shape\";\nimport {CanvasWhiteboardShapeOptions} from \"./canvas-whiteboard-shape-options\";\nimport {CanvasWhiteboardPoint} from \"../canvas-whiteboard-point\";\nimport {CanvasWhiteboardUpdate} from \"../canvas-whiteboard-update.model\";\n\nexport class CircleShape extends CanvasWhiteboardShape {\n    radius: number;\n\n    constructor(positionPoint?: CanvasWhiteboardPoint, options?: CanvasWhiteboardShapeOptions, radius?: number) {\n        super(positionPoint, options);\n        this.radius = radius || 0;\n    }\n\n    getShapeName(): string {\n        return 'CircleShape';\n    }\n\n    draw(context: CanvasRenderingContext2D) {\n        context.beginPath();\n        context.arc(this.positionPoint.x, this.positionPoint.y, this.radius, 0, Math.PI * 2, false);\n\n        Object.assign(context, this.options);\n\n        context.stroke();\n        if (this.options.shouldFillShape) {\n            context.fill();\n        }\n\n        context.closePath();\n    }\n\n    drawPreview(context: CanvasRenderingContext2D) {\n        this.positionPoint = new CanvasWhiteboardPoint(context.canvas.width / 2, context.canvas.height / 2);\n        this.radius = this.calculateRadius(context.canvas.width - 2, context.canvas.height / 2);\n        this.draw(context);\n    }\n\n    onUpdateReceived(update: CanvasWhiteboardUpdate) {\n        this.radius = this.calculateRadius(update.x, update.y);\n    }\n\n    calculateRadius(x: number, y: number): number {\n        return Math.sqrt(Math.pow(x - this.positionPoint.x, 2) + Math.pow(y - this.positionPoint.y, 2));\n    }\n}\n","import {CanvasWhiteboardShape} from \"./canvas-whiteboard-shape\";\nimport {CanvasWhiteboardShapeOptions} from \"./canvas-whiteboard-shape-options\";\nimport {CanvasWhiteboardPoint} from \"../canvas-whiteboard-point\";\nimport {CanvasWhiteboardUpdate} from \"../canvas-whiteboard-update.model\";\n\nexport class RectangleShape extends CanvasWhiteboardShape {\n    width: number;\n    height: number;\n\n    constructor(positionPoint?: CanvasWhiteboardPoint,\n                options?: CanvasWhiteboardShapeOptions,\n                width?: number,\n                height?: number) {\n        super(positionPoint, options);\n        this.width = width || 0;\n        this.height = height || 0;\n    }\n\n    getShapeName(): string {\n        return 'RectangleShape';\n    }\n\n    draw(context: CanvasRenderingContext2D) {\n        if (!this.width || !this.height) {\n            return;\n        }\n        context.beginPath();\n\n        Object.assign(context, this.options);\n\n        context.rect(this.positionPoint.x, this.positionPoint.y, this.width, this.height);\n\n        context.stroke();\n        if (this.options.shouldFillShape) {\n            context.fill();\n        }\n\n        context.closePath();\n    }\n\n    drawPreview(context: CanvasRenderingContext2D) {\n        this.positionPoint = new CanvasWhiteboardPoint(2, 2);\n        this.width = context.canvas.width - 4;\n        this.height = context.canvas.height - 4;\n        this.draw(context);\n    }\n\n    onUpdateReceived(update: CanvasWhiteboardUpdate) {\n        this.width = update.x - this.positionPoint.x;\n        this.height = update.y - this.positionPoint.y;\n    }\n}\n","import {CanvasWhiteboardShape} from \"./canvas-whiteboard-shape\";\nimport {CanvasWhiteboardShapeOptions} from \"./canvas-whiteboard-shape-options\";\nimport {CanvasWhiteboardPoint} from \"../canvas-whiteboard-point\";\nimport {CanvasWhiteboardUpdate} from \"../canvas-whiteboard-update.model\";\n\nexport class FreeHandShape extends CanvasWhiteboardShape {\n    linePositions: CanvasWhiteboardPoint[];\n\n    constructor(positionPoint?: CanvasWhiteboardPoint, options?: CanvasWhiteboardShapeOptions) {\n        super(positionPoint, options);\n        this.linePositions = [];\n    }\n\n    getShapeName(): string {\n        return 'FreeHandShape';\n    }\n\n    draw(context: CanvasRenderingContext2D) {\n        Object.assign(context, this.options);\n\n        context.beginPath();\n        context.moveTo(this.positionPoint.x, this.positionPoint.y);\n        // Draw a dot\n        context.lineTo(this.positionPoint.x + 1, this.positionPoint.y + 1);\n\n        // Normal fastest free hand drawing\n        // this.linePositions.forEach((linePosition) => {\n        //     context.lineTo(linePosition.x, linePosition.y);\n        // });\n\n        // Quadratic curves drawing\n        let i = 0;\n        while (i < this.linePositions.length) {\n            if (this.linePositions.length - i > 2) {\n                let controlPoint1 = this.linePositions[i];\n                let controlPoint2 = this.linePositions[i + 1];\n                let endPoint = this.linePositions[i + 2];\n                context.bezierCurveTo(controlPoint1.x,\n                    controlPoint1.y,\n                    controlPoint2.x,\n                    controlPoint2.y,\n                    endPoint.x,\n                    endPoint.y);\n                i += 2;\n            } else {\n                let linePosition = this.linePositions[i];\n                context.lineTo(linePosition.x, linePosition.y);\n                i += 1;\n            }\n        }\n\n        context.stroke();\n    }\n\n    drawPreview(context: CanvasRenderingContext2D) {\n        this.positionPoint = new CanvasWhiteboardPoint(2, 2);\n        this.linePositions = [\n            new CanvasWhiteboardPoint(context.canvas.width - 5, context.canvas.height * 0.3),\n            // new CanvasWhiteboardPoint(context.canvas.width * 0.4, context.canvas.height * 0.6),\n            new CanvasWhiteboardPoint(context.canvas.width * 0.2, context.canvas.height * 0.4),\n            new CanvasWhiteboardPoint(context.canvas.width * 0.6, context.canvas.height * 0.8),\n            new CanvasWhiteboardPoint(context.canvas.width, context.canvas.height)\n        ];\n\n        this.draw(context);\n    }\n\n    onUpdateReceived(update: CanvasWhiteboardUpdate) {\n        this.linePositions.push(new CanvasWhiteboardPoint(update.x, update.y));\n    }\n}\n","import {CanvasWhiteboardShape} from \"./canvas-whiteboard-shape\";\nimport {CanvasWhiteboardShapeOptions} from \"./canvas-whiteboard-shape-options\";\nimport {CanvasWhiteboardPoint} from \"../canvas-whiteboard-point\";\nimport {CanvasWhiteboardUpdate} from \"../canvas-whiteboard-update.model\";\n\nexport class SmileyShape extends CanvasWhiteboardShape {\n    radius: number;\n\n    constructor(positionPoint?: CanvasWhiteboardPoint, options?: CanvasWhiteboardShapeOptions, radius?: number) {\n        super(positionPoint, options);\n        this.options.shouldFillShape = true;\n        this.options.fillStyle = this.options.fillStyle || \"yellow\";\n\n        this.radius = radius || 0;\n    }\n\n    getShapeName(): string {\n        return 'SmileyShape';\n    }\n\n    draw(context: CanvasRenderingContext2D) {\n        context.beginPath();\n\n        Object.assign(context, this.options);\n\n        context.arc(this.positionPoint.x, this.positionPoint.y, this.radius, 0, Math.PI * 2, false);\n        context.fill();\n        context.stroke();\n\n        context.beginPath();\n        let leftEyeX = this.positionPoint.x - this.radius * 0.3;\n        let rightEyeX = this.positionPoint.x + this.radius * 0.3;\n        const eyesY = this.positionPoint.y - this.radius * 0.2;\n        const eyeSize = this.radius * 0.1;\n\n        context.arc(leftEyeX, eyesY, eyeSize, 0, 2 * Math.PI, false);\n        context.arc(rightEyeX, eyesY, eyeSize, 0, 2 * Math.PI, false);\n        context.fillStyle = this.options.strokeStyle;\n        context.fill();\n\n        // draw the mouth\n        context.beginPath();\n        context.arc(this.positionPoint.x, this.positionPoint.y, this.radius * 0.7, 0, Math.PI, false);\n        context.stroke();\n\n        context.closePath();\n    }\n\n    drawPreview(context: CanvasRenderingContext2D) {\n        this.positionPoint = new CanvasWhiteboardPoint(context.canvas.width / 2, context.canvas.height / 2);\n        this.radius = this.calculateRadius(context.canvas.width - 2, context.canvas.height / 2);\n        this.draw(context);\n    }\n\n    onUpdateReceived(update: CanvasWhiteboardUpdate) {\n        this.radius = this.calculateRadius(update.x, update.y);\n    }\n\n    calculateRadius(x: number, y: number): number {\n        return Math.sqrt(Math.pow(x - this.positionPoint.x, 2) + Math.pow(y - this.positionPoint.y, 2));\n    }\n}\n","import {CanvasWhiteboardShape} from \"./canvas-whiteboard-shape\";\nimport {CanvasWhiteboardShapeOptions} from \"./canvas-whiteboard-shape-options\";\nimport {CanvasWhiteboardPoint} from \"../canvas-whiteboard-point\";\nimport {CanvasWhiteboardUpdate} from \"../canvas-whiteboard-update.model\";\n\nexport class StarShape extends CanvasWhiteboardShape {\n    radius: number;\n    spikes: number;\n\n    constructor(positionPoint?: CanvasWhiteboardPoint,\n                options?: CanvasWhiteboardShapeOptions,\n                radius?: number,\n                spikes?: number) {\n        super(positionPoint, options);\n        this.radius = radius || 0;\n        this.spikes = spikes || 5;\n    }\n\n    getShapeName(): string {\n        return 'StarShape';\n    }\n\n    draw(context: CanvasRenderingContext2D) {\n        Object.assign(context, this.options);\n\n        let rotation = Math.PI / 2 * 3;\n        let spikeX = this.positionPoint.x;\n        let spikeY = this.positionPoint.y;\n        let step = Math.PI / this.spikes;\n\n        context.beginPath();\n        context.moveTo(this.positionPoint.x, this.positionPoint.y - this.radius);\n\n        for (let i = 0; i < this.spikes; i++) {\n            spikeX = this.positionPoint.x + Math.cos(rotation) * this.radius;\n            spikeY = this.positionPoint.y + Math.sin(rotation) * this.radius;\n            context.lineTo(spikeX, spikeY);\n            rotation += step;\n\n            spikeX = this.positionPoint.x + Math.cos(rotation) * (this.radius * 0.4);\n            spikeY = this.positionPoint.y + Math.sin(rotation) * (this.radius * 0.4);\n            context.lineTo(spikeX, spikeY);\n            rotation += step;\n            context.stroke();\n        }\n\n        context.lineTo(this.positionPoint.x, this.positionPoint.y - this.radius);\n        context.closePath();\n\n        context.stroke();\n\n        if (this.options.shouldFillShape) {\n            context.fill();\n        }\n    }\n\n    drawPreview(context: CanvasRenderingContext2D) {\n        this.positionPoint = new CanvasWhiteboardPoint(context.canvas.width / 2, context.canvas.height / 2);\n        this.radius = this.calculateRadius(context.canvas.width - 2, context.canvas.height / 2);\n        this.draw(context);\n    }\n\n    onUpdateReceived(update: CanvasWhiteboardUpdate) {\n        this.radius = this.calculateRadius(update.x, update.y);\n    }\n\n    calculateRadius(x: number, y: number): number {\n        return Math.sqrt(Math.pow(x - this.positionPoint.x, 2) + Math.pow(y - this.positionPoint.y, 2));\n    }\n}\n","import {CanvasWhiteboardShape} from \"./canvas-whiteboard-shape\";\nimport {CanvasWhiteboardShapeOptions} from \"./canvas-whiteboard-shape-options\";\nimport {CanvasWhiteboardPoint} from \"../canvas-whiteboard-point\";\nimport {CanvasWhiteboardUpdate} from \"../canvas-whiteboard-update.model\";\n\nexport class LineShape extends CanvasWhiteboardShape {\n    endPosition: CanvasWhiteboardPoint;\n\n    constructor(positionPoint?: CanvasWhiteboardPoint,\n                options?: CanvasWhiteboardShapeOptions,\n                endPosition?: CanvasWhiteboardPoint) {\n        super(positionPoint, options);\n        this.endPosition = endPosition || new CanvasWhiteboardPoint(this.positionPoint.x, this.positionPoint.y);\n    }\n\n    getShapeName(): string {\n        return 'LineShape';\n    }\n\n    draw(context: CanvasRenderingContext2D) {\n        if (!this.endPosition) {\n            return;\n        }\n        context.beginPath();\n        Object.assign(context, this.options);\n\n        context.moveTo(this.positionPoint.x, this.positionPoint.y);\n        context.lineTo(this.endPosition.x, this.endPosition.y);\n\n        context.closePath();\n        context.stroke();\n    }\n\n    drawPreview(context: CanvasRenderingContext2D) {\n        this.positionPoint = new CanvasWhiteboardPoint(0, 0);\n        this.endPosition = new CanvasWhiteboardPoint(context.canvas.width, context.canvas.height);\n        this.draw(context);\n    }\n\n    onUpdateReceived(update: CanvasWhiteboardUpdate) {\n        this.endPosition = new CanvasWhiteboardPoint(update.x, update.y);\n    }\n}\n","import {Injectable} from \"@angular/core\";\nimport {CanvasWhiteboardShape} from \"./canvas-whiteboard-shape\";\nimport {CircleShape} from \"./circle-shape\";\nimport {RectangleShape} from \"./rectangle-shape\";\nimport {FreeHandShape} from \"./free-hand-shape\";\nimport {CanvasWhiteboardShapeOptions} from \"./canvas-whiteboard-shape-options\";\nimport {CanvasWhiteboardPoint} from \"../canvas-whiteboard-point\";\nimport {SmileyShape} from \"./smiley-shape\";\nimport {StarShape} from \"./star-shape\";\nimport {LineShape} from \"./line-shape\";\nimport {BehaviorSubject, Observable} from \"rxjs\";\n\nexport interface INewCanvasWhiteboardShape<T extends CanvasWhiteboardShape> {\n    new(positionPoint?: CanvasWhiteboardPoint, options?: CanvasWhiteboardShapeOptions, ...args: any[]): T;\n}\n\n@Injectable()\nexport class CanvasWhiteboardShapeService {\n    private _registeredShapesSubject: BehaviorSubject<Array<INewCanvasWhiteboardShape<CanvasWhiteboardShape>>>;\n    public registeredShapes$: Observable<Array<INewCanvasWhiteboardShape<CanvasWhiteboardShape>>>;\n\n    constructor() {\n        this._registeredShapesSubject = new BehaviorSubject([\n            FreeHandShape,\n            LineShape,\n            RectangleShape,\n            CircleShape,\n            StarShape,\n            SmileyShape\n        ]);\n        this.registeredShapes$ = this._registeredShapesSubject.asObservable();\n    }\n\n    getShapeConstructorFromShapeName(shapeName: string): INewCanvasWhiteboardShape<CanvasWhiteboardShape> {\n        return this.getCurrentRegisteredShapes().find((shape) =>\n            (new shape).getShapeName() === shapeName);\n    }\n\n    getCurrentRegisteredShapes(): Array<INewCanvasWhiteboardShape<CanvasWhiteboardShape>> {\n        return this._registeredShapesSubject.getValue();\n    }\n\n    isRegisteredShape(shape: INewCanvasWhiteboardShape<CanvasWhiteboardShape>) {\n        return this.getCurrentRegisteredShapes().indexOf(shape) !== -1;\n    }\n\n    registerShape(shape: INewCanvasWhiteboardShape<CanvasWhiteboardShape>) {\n        if (this.isRegisteredShape(shape)) {\n            console.warn(`You tried to register a shape:${shape}, but is has already been registered.`);\n            return;\n        }\n\n        let registeredShapes = this.getCurrentRegisteredShapes();\n        registeredShapes.push(shape);\n        this._registeredShapesSubject.next(registeredShapes);\n    }\n\n    registerShapes(shapes: Array<INewCanvasWhiteboardShape<CanvasWhiteboardShape>>) {\n        this._registeredShapesSubject.next(\n            this.getCurrentRegisteredShapes()\n                .concat(\n                    shapes.filter((shape) => {\n                        if (this.isRegisteredShape(shape)) {\n                            console.warn(`You tried to register a shape:${shape}, but is has already been registered.`);\n                            return false;\n                        }\n\n                        return true;\n                    })\n                )\n        );\n    }\n\n    unregisterShape(shape: INewCanvasWhiteboardShape<CanvasWhiteboardShape>) {\n        this._registeredShapesSubject.next(\n            this.getCurrentRegisteredShapes().filter((registeredShape) => registeredShape !== shape)\n        );\n    }\n\n    unregisterShapes(shapes: Array<INewCanvasWhiteboardShape<CanvasWhiteboardShape>>) {\n        this._registeredShapesSubject.next(\n            this.getCurrentRegisteredShapes().filter((shape) => shapes.indexOf(shape) === -1)\n        );\n    }\n}\n"],"names":["_this","this","_redrawBackground","_shapesMap","forEach","shape","isVisible","draw","context","CanvasWhiteboardComponent","prototype","_addCurrentShapeDataToAnUpdate","update","selectedShape","selectedShapeConstructor","getShapeName","selectedShapeOptions","Object","assign","CanvasWhiteboardShapeOptions","generateShapePreviewOptions","lineWidth","shouldFillShape","fillColor","fillStyle","strokeStyle","strokeColor","lineJoin","lineCap","_prepareUpdateForBatchDispatch","_batchUpdates","push","cloneDeep","_updateTimeout","setTimeout","onBatchUpdate","emit","batchUpdateTimeoutDuration","drawUpdates","updates","_canDraw","_drawMissingUpdates","_draw","_updatesNotDrawn","concat","length","updatesToDraw","_drawImage","image","x","y","width","height","offsetX","offsetY","arguments","canvas","finalDrawX","finalDrawY","finalDrawWidth","finalDrawHeight","imageWidth","imageHeight","radius","Math","min","newWidth","newHeight","aspectRatio","abs","drawImage","generateCanvasDataUrl","returnedDataType","returnedDataQuality","toDataURL","generateCanvasBlob","callbackFn","toBlobMethod","toBlob","bind","msToBlob","callback","blob","downloadCanvasImage","downloadData","customFileName","undefined","window","navigator","msSaveOrOpenBlob","downloadLink","document","createElement","setAttribute","fileName","downloadedFileName","Date","valueOf","_generateDataTypeString","body","appendChild","click","removeChild","_saveCanvasBlob","generateCanvasData","saveLocal","generatedData","onSave","shouldDownloadDrawing","split","toggleStrokeColorPicker","value","showStrokeColorPicker","_isNullOrUndefined","toggleFillColorPicker","showFillColorPicker","toggleShapeSelector","showShapeSelector","selectShape","newShapeBlueprint","getDrawingHistory","_updateHistory","_unsubscribe","subscription","unsubscribe","_generateUUID","_random4","floor","random","toString","substring","ngOnDestroy","_resizeSubscription","_registeredShapesSubscription","_canvasWhiteboardServiceSubscriptions","type","Component","args","selector","template","styles","DEFAULT_STYLES","NgZone","ChangeDetectorRef","CanvasWhiteboardService","CanvasWhiteboardShapeService","options","Input","imageUrl","drawButtonClass","clearButtonClass","undoButtonClass","redoButtonClass","saveDataButtonClass","drawButtonText","clearButtonText","undoButtonText","redoButtonText","saveDataButtonText","drawButtonEnabled","clearButtonEnabled","undoButtonEnabled","redoButtonEnabled","saveDataButtonEnabled","colorPickerEnabled","strokeColorPickerEnabled","fillColorPickerEnabled","startingColor","scaleFactor","drawingEnabled","shapeSelectorEnabled","onClear","Output","onUndo","onRedo","onImageLoaded","ViewChild","static","_incompleteShapesCanvas","CanvasWhiteboardShapeSelectorComponent","_elementRef","_canvasWhiteboardShapeService","onToggleShapeSelector","EventEmitter","onShapeSelected","registeredShapes$","closeOnExternalClick","event","nativeElement","contains","target","preventDefault","host","(document:mousedown)","(document:touchstart)","ElementRef","shapeOptions","CanvasWhiteboardColorPickerComponent","selectedColor","showColorPicker","onToggleColorPicker","onColorSelected","onSecondaryColorSelected","ngOnInit","_context","getContext","createColorPalette","gradient","createLinearGradient","addColorStop","fillRect","toggleColorPicker","determineColorFromCanvas","canvasRect","getBoundingClientRect","imageData","getImageData","clientX","left","clientY","top","data","selectColor","color","previewText","CanvasWhiteboardShapePreviewComponent","ngAfterViewInit","drawShapePreview","ngOnChanges","changes","shapeConstructor","clearRect","CanvasWhiteboardPoint","drawPreview","CanvasWhiteboardModule","NgModule","imports","CommonModule","declarations","providers","exports","CanvasWhiteboardUpdateType","START","DRAG","STOP","CanvasWhiteboardUpdate","UUID","deserializeJson","json","parsedJson","JSON","parse","e","console","error","stringify","objectToSerialize","toFixed","uuid","_canvasDrawSubject","Subject","canvasDrawSubject$","asObservable","_canvasClearSubject","canvasClearSubject$","_canvasUndoSubject","canvasUndoSubject$","_canvasRedoSubject","canvasRedoSubject$","drawCanvas","next","clearCanvas","undoCanvas","updateUUD","redoCanvas","CanvasWhiteboardShape","positionPoint","onStopReceived","CircleShape","_super","call","__extends","beginPath","arc","PI","stroke","fill","closePath","calculateRadius","onUpdateReceived","sqrt","pow","RectangleShape","rect","FreeHandShape","linePositions","moveTo","lineTo","i","controlPoint1","controlPoint2","endPoint","bezierCurveTo","linePosition","SmileyShape","leftEyeX","rightEyeX","eyesY","eyeSize","StarShape","spikes","rotation","spikeX","spikeY","step","cos","sin","LineShape","endPosition","_registeredShapesSubject","BehaviorSubject","getShapeConstructorFromShapeName","shapeName","getCurrentRegisteredShapes","find","getValue","isRegisteredShape","indexOf","registerShape","warn","registeredShapes","registerShapes","shapes","filter","unregisterShape","registeredShape","unregisterShapes","Injectable","ngZone","_changeDetector","_canvasWhiteboardService","_clientDragging","_undoStack","_redoStack","Map","_incompleteShapesMap","canvasWhiteboardShapePreviewOptions","defineProperty","get","_imageUrl","set","_imageElement","_redrawHistory","_initInputsFromOptions","_initCanvasEventListeners","_initCanvasServiceObservables","_incompleteShapesCanvasContext","isEqual","currentValue","previousValue","_calculateCanvasWidthAndHeight","property","runOutsideAngular","fromEvent","pipe","debounceTime","distinctUntilChanged","subscribe","run","_redrawCanvasOnResize","addEventListener","_canvasKeyDown","_undoCanvas","_redoCanvas","parentNode","clientWidth","clientHeight","_loadImage","Image","src","clearCanvasLocal","_removeCanvasData","save","restore","_drawStartingColor","previousFillStyle","getShouldDraw","getDrawingEnabled","toggleDrawingEnabled","setDrawingEnabled","changeColor","newStrokeColor","changeStrokeColor","detectChanges","changeFillColor","newFillColor","undoLocal","undo","updateUUID","pop","has","drawAllShapes","redoLocal","redo","canvasUserEvents","updateType","eventPosition","_getCanvasEventPosition","_lastUUID","_prepareToSendUpdate","eventData","canvasBoundingRect","hasTouches","touches","changedTouches","scaleWidth","scaleHeight","xPosition","yPosition","ctrlKey","metaKey","keyCode","updateShapeConstructor","_drawIncompleteShapes","delete","_swapCompletedShapeToActualCanvas","_resetIncompleteShapeCanvas"],"mappings":"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"}